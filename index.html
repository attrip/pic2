<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Picture Diary — 25分集中ノート入力</title>
    <style>
      :root { --bg:#faf7f2; --fg:#222; --muted:#666; --accent:#4b9; --surface:#fff; --shadow:0 8px 32px rgba(0,0,0,.06); }
      html, body { height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", sans-serif; margin: 0; line-height: 1.7; color: var(--fg); background: radial-gradient(1200px 600px at 10% -10%, #fff, var(--bg)); }
      .wrap { max-width: 820px; margin: 32px auto 48px; padding: 0 16px; }
      h1 { margin: 0 0 6px; font-weight: 750; letter-spacing: .2px; }
      .note { color: var(--muted); font-size: 0.98em; margin: 0 0 14px; }
      .topbar { display: flex; align-items: baseline; gap: 16px; flex-wrap: wrap; }
      .timer { font-size: 28px; font-weight: 800; letter-spacing: .5px; }
      .progress { height: 6px; background: #e9e5df; border-radius: 999px; overflow: hidden; box-shadow: inset 0 1px 0 rgba(0,0,0,.03); }
      .bar { height: 100%; width: 100%; background: linear-gradient(90deg, #7dd, #4b9); transition: width .3s ease; }
      .controls { display:flex; gap: 8px; margin: 10px 0 12px; flex-wrap: wrap; }
      button { padding: 10px 14px; font-size: 14px; border: 0; border-radius: 8px; background: #eff7f5; color: #135; cursor: pointer; }
      button:hover { filter: brightness(0.98); }
      button:active { transform: translateY(1px); }
      button.listening { background: #ffe9e3; color: #a2353a; }
      /* チャット関連は廃止 */
      .plain { margin-top: 12px; }
      .plain textarea { width: 100%; min-height: 360px; padding: 18px 18px 28px; font-size: 18px; line-height: 1.85; box-sizing: border-box; border-radius: 14px; border: 1px solid #e8e2da; background: var(--surface); box-shadow: var(--shadow); }
      .plain textarea:focus { outline: 2px solid #bfe9dd; outline-offset: 2px; }
      .statusline { display:flex; justify-content: space-between; color: var(--muted); font-size: .92em; margin: 8px 2px 0; }
      .hidden { display: none; }
      .out { margin-top: 22px; }
      .out h3 { margin: 18px 0 8px; }
      textarea.output { width: 100%; background: #0c0c0c; color: #e5ffe5; padding: 14px; border-radius: 10px; box-sizing: border-box; min-height: 120px; white-space: pre-wrap; height: auto; overflow: auto; }
      .small { color: var(--muted); font-size: .9em; }
      a { color: #06c; text-decoration: none; }
      a:hover { text-decoration: underline; }

      /* 集中モード（UIクロームを最小化） */
      body.zen .note,
      body.zen .controls,
      body.zen .statusline { display: none; }
      body.zen .wrap { margin-top: 24px; }
      /* ノート専用表示 */
      .chromeToggle { position: fixed; top: 10px; right: 10px; opacity: .5; background: #eef6f3; border-radius: 999px; padding: 6px 10px; border: 1px solid #dceae5; box-shadow: 0 2px 8px rgba(0,0,0,.05); cursor: pointer; }
      .chromeToggle:hover { opacity: .9; }
      .newSession { position: fixed; top: 10px; right: 56px; opacity: .6; background: #ffe; border-radius: 999px; padding: 6px 10px; border: 1px solid #eee2a8; box-shadow: 0 2px 8px rgba(0,0,0,.05); cursor: pointer; }
      .newSession:hover { opacity: .95; }
      /* 入力モード切替は廃止 */
      body.zen .topbar .timer { position: fixed; top: 12px; left: 12px; font-size: 16px; opacity: .65; }
      body.zen .progress { position: fixed; top: 0; left: 0; right: 0; height: 2px; border-radius: 0; }

      /* トースト通知 */
      #toast { position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); background: rgba(20,20,20,.9); color: #fff; padding: 10px 14px; border-radius: 10px; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
      #toast.show { opacity: 1; }
    </style>
  </head>
  <body>
    <button id="newSession" class="newSession" title="新規セッション（全部クリア）">新規</button>
    <button id="chromeToggle" class="chromeToggle" title="UI表示切替">•••</button>
    <div class="wrap">
      <h1>Picture Diary</h1>
      <p class="note">文章だけに集中してください。音楽と画像の提案は自動で行います。書き始めると 25 分タイマーがスタートします（⌘/Ctrl + Enter で生成）。</p>

      <div class="topbar">
        <div class="timer" id="timer">25:00</div>
      </div>
      <div class="progress"><div class="bar" id="bar" style="width:100%"></div></div>
      <div class="controls">
        <button id="startPause">開始</button>
        <button id="reset">リセット</button>
        <button id="generate">今すぐ生成</button>
        <button id="advice">アドバイス作成</button>
        <button id="pres">プレゼン支援</button>
        <button id="music">音楽依頼</button>
        <button id="rap">ラップ作成</button>
        <button id="image">画像依頼</button>
        <button id="tagMusic">＋音楽タグ</button>
        <button id="tagRap">＋ラップタグ</button>
        <button id="tagImage">＋画像タグ</button>
        <button id="voice">音声入力</button>
      </div>
      <p class="small" id="voiceNotice">音声入力はデスクトップ版 Chrome / Edge でのみ動作します。Atlas や Safari などでは利用できません。</p>
      <!-- チャットUIは削除 -->
      <div id="plainWrap" class="plain">
        <textarea id="plainInput" placeholder="ここに自由に書いてください（⌘/Ctrl + Enter で生成）"></textarea>
      </div>
      <div class="statusline">
        <div><span id="wc">0</span> words ・ <span id="cc">0</span> chars</div>
        <div id="save">&nbsp;</div>
      </div>

      <section id="outputs" class="out hidden">
      <h3>ChatGPT へ渡す依頼文（まとめ）</h3>
      <textarea id="chatOut" class="output" readonly></textarea>
      <div style="display:flex; gap:8px; margin-top:8px; flex-wrap: wrap;">
        <button data-copy="chatOut">コピー</button>
        <button id="openRaw">全量プレビュー</button>
        <button id="saveTxt">.txt保存</button>
        <a href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer"><button>ChatGPT を開く</button></a>
      </div>
      </section>
    </div>
    <div id="toast" role="status" aria-live="polite"></div>

    <script>
      const el = (id) => document.getElementById(id);
      const fmt = (s) => String(s).padStart(2, '0');
      const summary = (t) => { t=(t||'').trim(); return t.length>140 ? t.slice(0,140)+'…' : t; };

      // Pomodoro 25:00 timer
      let duration = 25 * 60;
      let remaining = duration;
      let timerId = null;
      let hasStarted = false;
      function renderTimer(){
        el('timer').textContent = `${fmt(Math.floor(remaining/60))}:${fmt(remaining%60)}`;
        const p = Math.max(0, Math.min(1, remaining / duration));
        const bar = document.getElementById('bar');
        if (bar) bar.style.width = `${Math.round(p*100)}%`;
      }
      function beep(){}
      function start(){
        if(timerId) return;
        timerId = setInterval(()=>{
          remaining--;
          if(remaining<=0){
            clearInterval(timerId); timerId=null; remaining=0; renderTimer(); beep(); generate();
          } else { renderTimer(); }
        }, 1000);
        hasStarted = true;
        el('startPause').textContent='一時停止';
      }
      function pause(){ if(!timerId) return; clearInterval(timerId); timerId=null; el('startPause').textContent='再開'; }
      function reset(){ pause(); remaining=duration; renderTimer(); hasStarted = false; el('startPause').textContent='開始'; }
      el('startPause').addEventListener('click', ()=>{ timerId ? pause() : start(); });
      el('reset').addEventListener('click', reset);
      el('generate').addEventListener('click', generate);
      renderTimer();
      // チャット入力: メッセージ配列 + 自動開始 + 入力オートリサイズ + カウント + 自動保存
      // チャット要素は廃止
      const plainEl = el('plainInput');
      // チャットラッパーなし
      const plainWrap = el('plainWrap');
      // ノート入力のみ利用（チャット機能は廃止）
      // 入力のローカル保存/復元（セッションをまたいでも保持）
      const voiceBtn = el('voice');
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      let recognition = null;
      let voiceKeepAlive = false;
      let voiceListening = false;
      let micReady = false;
      let micDenied = false;
      const fatalSpeechErrors = ['not-allowed','service-not-allowed','audio-capture','network'];
      const speechErrorMessages = {
        'not-allowed':'マイクへのアクセスを許可してください',
        'service-not-allowed':'マイクへのアクセスを許可してください',
        'no-speech':'音声が検出されませんでした',
        'audio-capture':'マイクが検出できませんでした',
        'network':'音声認識サービスに接続できませんでした',
      };

      function disableVoiceButton(text, tooltip, toastMessage){
        if (!voiceBtn) return;
        voiceBtn.disabled = true;
        voiceBtn.textContent = text;
        voiceBtn.title = tooltip || text;
        voiceBtn.classList.remove('listening');
        if (toastMessage) { showToast(toastMessage); }
      }

      async function requestMicAccess(){
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          const err = new Error('unsupported');
          err.name = 'NotSupportedError';
          throw err;
        }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop()); // 取得したトラックは即停止して解放
      }

      function setVoiceState(active){
        voiceListening = !!active;
        if (!voiceBtn) return;
        voiceBtn.textContent = active ? '音声入力停止' : '音声入力';
        voiceBtn.classList.toggle('listening', !!active);
      }

      function appendVoiceText(text){
        if (!text) return;
        const trimmed = text.trim();
        if (!trimmed) return;
        const needsBreak = plainEl.value && !plainEl.value.endsWith('\n');
        plainEl.value += (needsBreak ? '\n' : '') + trimmed + '\n';
        updateCounts();
        queueSave();
        if (!hasStarted && !timerId && remaining === duration) { start(); }
        plainEl.focus();
      }
      if (SpeechRecognition && voiceBtn) {
        recognition = new SpeechRecognition();
        recognition.lang = 'ja-JP';
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.addEventListener('result', (event)=>{
          let transcript = '';
          for (let i = event.resultIndex; i < event.results.length; i += 1) {
            const res = event.results[i];
            if (res.isFinal && res[0]) {
              transcript += res[0].transcript;
            }
          }
          appendVoiceText(transcript);
        });

        recognition.addEventListener('start', ()=>{
          const wasActive = voiceListening;
          setVoiceState(true);
          if (!wasActive) { showToast('音声入力を開始しました'); }
        });

        recognition.addEventListener('end', ()=>{
          if (voiceKeepAlive) {
            try { recognition.start(); } catch(e) { voiceKeepAlive = false; setVoiceState(false); showToast('音声入力を再開できませんでした'); }
          } else {
            if (voiceListening) { showToast('音声入力を停止しました'); }
            setVoiceState(false);
          }
        });

        recognition.addEventListener('error', (event)=>{
          voiceKeepAlive = false;
          setVoiceState(false);
          const detail = speechErrorMessages[event.error] || `音声入力エラー: ${event.error}`;
          showToast(detail);
          if (fatalSpeechErrors.includes(event.error)) {
            micDenied = true;
            disableVoiceButton('音声入力非対応', detail);
          }
        });

        voiceBtn.addEventListener('click', async ()=>{
          if (!recognition) {
            disableVoiceButton('音声入力非対応', '音声入力機能を初期化できませんでした', 'このブラウザでは音声入力を利用できません');
            return;
          }
          if (voiceListening || voiceKeepAlive) {
            voiceKeepAlive = false;
            try { recognition.stop(); } catch(e) { setVoiceState(false); }
            return;
          }
          if (!micReady && !micDenied) {
            try {
              await requestMicAccess();
              micReady = true;
            } catch(err) {
              micDenied = true;
              const message =
                err.name === 'NotAllowedError'
                  ? 'マイクへのアクセスを許可してください'
                  : 'このブラウザではマイクを利用できません';
              disableVoiceButton('音声入力非対応', message, message);
              return;
            }
          }
          voiceKeepAlive = true;
          try {
            recognition.start();
          } catch(e) {
            voiceKeepAlive = false;
            const message =
              e.name === 'NotAllowedError'
                ? 'マイクへのアクセスを許可してください'
                : e.name === 'NotFoundError'
                  ? 'マイクが検出できませんでした'
                  : e.name === 'NotSupportedError'
                    ? 'このブラウザでは音声入力を利用できません'
                    : '音声入力を開始できませんでした';
            showToast(message);
            if (['NotAllowedError','NotFoundError','NotSupportedError'].includes(e.name)) {
              micDenied = true;
              disableVoiceButton('音声入力非対応', message);
            }
          }
        });
      } else if (voiceBtn) {
        disableVoiceButton('音声入力非対応', 'ブラウザが音声入力に対応していません', 'このブラウザでは音声入力を利用できません');
      }
      window.addEventListener('beforeunload', ()=>{ voiceKeepAlive = false; if (recognition && voiceListening) { try { recognition.stop(); } catch(e) {} } });
      const STORAGE_KEY = 'pd_plain_v3';
      function loadSaved(){
        try {
          const v = localStorage.getItem(STORAGE_KEY);
          if (typeof v === 'string' && v.length > 0) {
            plainEl.value = v;
          }
        } catch(e) {}
      }
      function saveNow(){
        try {
          localStorage.setItem(STORAGE_KEY, plainEl.value || '');
          const s = el('save');
          if (s) { s.textContent = '保存済み'; setTimeout(()=>{ s.textContent='\u00a0'; }, 1000); }
        } catch(e) {}
      }
      let saveTimer = null;
      function queueSave(){
        try { if (saveTimer) clearTimeout(saveTimer); } catch(e) {}
        saveTimer = setTimeout(saveNow, 400);
      }
      function getAllText(){ return plainEl.value || ''; }
      function updateCounts(){ const t = getAllText(); const words=(t.trim().match(/\S+/g)||[]).length; el('wc').textContent=String(words); el('cc').textContent=String(t.length); }
      // 旧キーのクリアはしない（自動削除は事故の元）、必要なら新キーへ移行
      // 起動時に保存内容を復元
      loadSaved();
      // 入力開始でタイマー開始
      plainEl.addEventListener('input', ()=>{
        if(!hasStarted && !timerId && remaining===duration){ start(); }
        updateCounts();
        queueSave();
      });
      // ページ離脱時も念のため保存
      window.addEventListener('beforeunload', saveNow);

      // 音楽性プロファイル定義
      const MUSIC_PROFILES = [
        {
          id:'urban-night',
          label:'都会夜景シンセ（synthwave / citypop）',
          style:'synthwave / citypop',
          bpm:112,
          instruments:['synth bass','retro drums','pads','electric piano'],
          mood:'都会の夜景が滲むクールで艶やかな音楽性',
          keywords:{
            mood:['夜','ネオン','都会','雨','ビル','街灯','ハイウェイ','深夜','都市','光る'],
            tempo:['駆け抜け','滑走','ドライブ','疾走'],
            imagery:['サイバーパンク','高速道路','摩天楼'],
            tags:['#citypop','#synthwave','#citynight']
          },
          aliases:['citypop','synthwave','city wave'],
          energyLevel:'mid',
          baseScore:3
        },
        {
          id:'organic-ambient',
          label:'自然系オーガニック（ambient / organic）',
          style:'ambient / organic',
          bpm:96,
          instruments:['acoustic guitar','piano','soft percussion','field recordings'],
          mood:'自然の息遣いと柔らかな余韻を感じる音楽性',
          keywords:{
            mood:['自然','森','海','山','風','空','川','光','緑','水音','草原','木漏れ日'],
            tempo:['ゆったり','柔らか','広がる','深呼吸'],
            imagery:['焚き火','木々','波','朝焼け'],
            tags:['#ambient','#organic','#自然']
          },
          aliases:['ambient','organic','healing'],
          energyLevel:'low',
          baseScore:3
        },
        {
          id:'sunny-pop',
          label:'晴れやかエレクトロポップ（upbeat pop）',
          style:'upbeat pop / electronic',
          bpm:128,
          instruments:['drums','bass','synth lead','claps'],
          mood:'高揚感と明るさがはじけるダンサブルな音楽性',
          keywords:{
            mood:['楽しい','嬉','ワクワク','陽気','笑','ハッピー','きらきら','祝う'],
            tempo:['ハイテンポ','踊る','弾ける','アップ'],
            imagery:['朝日','フェス','ホリデー'],
            tags:['#pop','#dance','#happy']
          },
          aliases:['upbeat','dance pop','electro pop'],
          energyLevel:'high',
          baseScore:2
        },
        {
          id:'melancholy-lofi',
          label:'夜更けローファイ（lo-fi chill）',
          style:'lo-fi chill',
          bpm:80,
          instruments:['warm keys','vinyl noise','soft drums','sub bass'],
          mood:'静かな哀愁と内省を帯びた温かな音楽性',
          keywords:{
            mood:['悲しい','寂','疲れ','静か','落ち着','雨','夜更け','独り','眠れない','淡い'],
            tempo:['ゆっくり','チル','まどろむ','Lo-Fi','チルい'],
            imagery:['雨音','喫茶','夜道','灯り'],
            tags:['#lofi','#chill','#夜']
          },
          aliases:['lofi','lo-fi','chillhop','midnight'],
          energyLevel:'low',
          baseScore:2
        },
        {
          id:'dnb-rush',
          label:'疾走ドラムンベース（drum & bass）',
          style:'drum & bass',
          bpm:172,
          instruments:['breakbeat drums','reese bass','pads'],
          mood:'緊迫感と疾走感で駆け抜ける攻めの音楽性',
          keywords:{
            mood:['疾走','焦り','緊張','駆け抜け','戦い','攻める','スリル'],
            tempo:['高速','ハイテンポ','ドライブ','アドレナリン'],
            tags:['#dnb','#drumandbass','#liquid'],
            imagery:['渋滞','疾走感','SFアクション']
          },
          aliases:['dnb','drum and bass','jungle'],
          energyLevel:'high',
          baseScore:1
        },
        {
          id:'trap-dark',
          label:'モダントラップ（modern trap）',
          style:'modern trap',
          bpm:138,
          instruments:['808 bass','snappy drums','atmospheric pads','fx'],
          mood:'重心の低いビートで緊張感を煽る攻撃的な音楽性',
          keywords:{
            mood:['攻め','挑戦','野心','闘志','ストリート','反骨','ダーク','荒れる'],
            tempo:['跳ねる','バウンス','重厚','ドロップ'],
            tags:['#trap','#drill','#808'],
            energy:['尖る','鋭い']
          },
          aliases:['trap','drill','808'],
          energyLevel:'mid-high',
          baseScore:2
        },
        {
          id:'boom-bap',
          label:'クラシック・ブーンバップ（boom bap / lo-fi）',
          style:'boom bap / lo-fi',
          bpm:90,
          instruments:['dusty drums','upright bass','jazz keys','vinyl noise'],
          mood:'土臭いグルーヴで言葉を押し出す芯のある音楽性',
          keywords:{
            mood:['語る','ストーリー','回想','日常','地に足','通り'],
            tempo:['首振り','スウィング','スローバウンス'],
            tags:['#boombap','#hiphopclassic','#jazzhop'],
            imagery:['レコード','ストリート','地下鉄']
          },
          aliases:['boom bap','boombap','golden era'],
          energyLevel:'mid',
          baseScore:2
        },
        {
          id:'dreamy-house',
          label:'ドリーミー・ハウス（dreamy house）',
          style:'dreamy house',
          bpm:124,
          instruments:['four-on-the-floor drums','airy pads','chord stabs','sub bass'],
          mood:'浮遊感のあるビートで没入させる幻想的な音楽性',
          keywords:{
            mood:['浮遊','夢見','きらめき','幻想','眠い','クラブ','深夜'],
            tempo:['四つ打ち','ステップ','跳ねる'],
            tags:['#house','#deephouse','#dreamy'],
            imagery:['クラブ','夜明け','朝まで']
          },
          aliases:['house','deep house','dreamy'],
          energyLevel:'mid-high',
          baseScore:1
        },
        {
          id:'lofi-chillhop',
          label:'ミッドナイト・チルホップ（lo-fi chillhop）',
          style:'lo-fi chillhop',
          bpm:82,
          instruments:['warm keys','soft drums','bass'],
          mood:'落ち着いた内省で心拍を整える柔らかな音楽性',
          keywords:{
            mood:['静か','穏やか','集中','瞑想','深夜','コーヒー','雨音','のんびり','ぼんやり'],
            tempo:['スロー','チル','スムース'],
            tags:['#chillhop','#study','#relax'],
            imagery:['書斎','ベッドサイド','読書']
          },
          aliases:['chillhop','study beats','lofi beats'],
          energyLevel:'low',
          baseScore:1
        }
      ];
      const MAGIC_DESCRIPTORS = {
        temperature: [
          {keywords:['熱','炎','燃','灼','夏','汗','灼熱','灼け'], phrase:'焦げた夜風'},
          {keywords:['冷','氷','雪','凍','冬','寒','霜','冷たい'], phrase:'透きとおる朝霧'},
          {keywords:['雨','湿','雫','涙','霧','霜','夜'], phrase:'湿った月影'},
        ],
        brightness: [
          {keywords:['光','輝','明','朝','陽','星','煌','キラ','ネオン','煌め'], phrase:'きらめくネオン'},
          {keywords:['暗','影','闇','夜','深夜','黒','月','黄昏'], phrase:'煤けた月光'},
          {keywords:['柔','淡','霞','薄','春','桜','優','柔ら'], phrase:'淡く溶ける薄明'},
        ],
        motion: [
          {keywords:['走','駆','速','急','攻','疾走','高鳴','突き抜け','ドライブ','スピード'], phrase:'駆け抜けるビート'},
          {keywords:['揺','緩','ゆっくり','漂','揺ら','チル','まどろ','穏やか'], phrase:'揺らぐ鼓動'},
          {keywords:['静','止','凍','固','余韻','静寂','沈黙','静け'], phrase:'静かに滲むリズム'},
        ]
      };
      const MAGIC_FALLBACK = {
        temperature: 'ぬくもりを抱く風',
        brightness: 'ぼんやり灯る街灯',
        motion: '呼吸するグルーヴ'
      };
      function normalizeMusicText(text){
        const raw = text || '';
        const lower = raw.toLowerCase();
        const hashtags = Array.from(lower.match(/#[^\s#]+/g) || []);
        const exclamations = (raw.match(/[！!？?。\.]/g) || []).length;
        return { raw, lower, hashtags, exclamations };
      }

      function keywordScore(context, list, weight){
        if (!Array.isArray(list) || list.length === 0) return 0;
        let score = 0;
        list.forEach(token=>{
          if (!token) return;
          const normalized = token.toLowerCase();
          if (context.raw.includes(token) || context.lower.includes(normalized)) {
            score += weight;
          }
        });
        return score;
      }

      function inferMusic(text){
        const ctx = normalizeMusicText(text);
        let best = MUSIC_PROFILES[MUSIC_PROFILES.length - 1];
        let bestScore = -999;
        MUSIC_PROFILES.forEach(profile=>{
          let score = profile.baseScore || 0;
          const kw = profile.keywords || {};
          score += keywordScore(ctx, kw.mood, 3.5);
          score += keywordScore(ctx, kw.tempo, 2.6);
          score += keywordScore(ctx, kw.imagery, 2.2);
          score += keywordScore(ctx, kw.energy, 1.4);
          if (Array.isArray(kw.tags)) {
            kw.tags.forEach(tag=>{
              const normalizedTag = tag.toLowerCase();
              if (ctx.hashtags.includes(normalizedTag)) {
                score += 5;
              }
            });
          }
          if (Array.isArray(kw.exclude)) {
            score -= keywordScore(ctx, kw.exclude, 3.5);
          }
          if (Array.isArray(profile.aliases)) {
            profile.aliases.forEach(alias=>{
              if (ctx.lower.includes(alias.toLowerCase())) {
                score += 4;
              }
            });
          }
          if (profile.energyLevel === 'high' && ctx.exclamations >= 5) score += 1.5;
          if (profile.energyLevel === 'low' && ctx.exclamations <= 2) score += 1.2;
          if (score > bestScore) {
            bestScore = score;
            best = profile;
          }
        });
        return {...best, origin:'auto'};
      }

      function pickMagicPhrase(ctx, axis){
        const descriptors = MAGIC_DESCRIPTORS[axis] || [];
        for (const item of descriptors){
          if ((item.keywords || []).some(kw=> ctx.raw.includes(kw) || ctx.lower.includes(kw.toLowerCase()))) {
            return item.phrase;
          }
        }
        return MAGIC_FALLBACK[axis];
      }

      function buildMagicPhrase(text){
        const ctx = normalizeMusicText(text);
        const temp = pickMagicPhrase(ctx, 'temperature');
        const light = pickMagicPhrase(ctx, 'brightness');
        const motion = pickMagicPhrase(ctx, 'motion');
        // 同じフレーズが続かないよう、重複時はフォールバックへ差し替え
        const dedupTemp = temp;
        const dedupLight = light === dedupTemp ? MAGIC_FALLBACK.brightness : light;
        const dedupMotion = motion === dedupTemp || motion === dedupLight ? MAGIC_FALLBACK.motion : motion;
        return `${dedupTemp}と${dedupLight}、${dedupMotion}`;
      }

      function inferImage(text){
        const t = text || '';
        if (['夜','ネオン','都会'].some(k=>t.includes(k))) return {style:'cinematic night, neon lights, high contrast', subject:'夜の街並み'};
        if (['自然','森','海','山','空','風','光'].some(k=>t.includes(k))) return {style:'pastel watercolor, soft light, atmospheric', subject:'自然の情景'};
        if (['楽しい','嬉','ワクワク','陽気'].some(k=>t.includes(k))) return {style:'colorful illustration, playful, clean', subject:'明るい日常の一場面'};
        if (['悲しい','寂','静か','落ち着'].some(k=>t.includes(k))) return {style:'moody film still, shallow depth of field', subject:'静かな部屋の一角'};
        return {style:'minimal, soft light, clean composition', subject:'印象的な日常の瞬間'};
      }

      function currentText(){
        // 常に全文を対象（選択中でも誤って一部だけにならないように）
        return plainEl.value || '';
      }

      // 出力欄の自動リサイズ（省略されて見えない問題の体感改善）
      function setOutput(value){
        const out = el('chatOut');
        out.value = value || '';
        // Auto-resize to fit content
        out.style.height = 'auto';
        out.style.height = (out.scrollHeight + 4) + 'px';
      }

      function generate(){
        const text = currentText();
        const full = (text || '');
        const m = inferMusic(text);
        const img = inferImage(text);
        const magic = buildMagicPhrase(full);

        const inputLen = full.length;
        const chatSeed = [
          'あなたは私の相棒です。以下の文章を材料に、短い要約と内省（各1〜3文）を返し、その内容に最も合う音楽（Sunoで実現可能）と画像の方向性を日本語で具体提案してください。',
          '',
          `【入力（全文） ${inputLen}字】`,
          '```',
          full || '(なし)',
          '```',
          '',
          '【出力要件】',
          '- 要約（1〜3文）',
          '- 内省（1〜3文）',
          `- 音楽の提案（例: 音楽性=${m.mood}, スタイル=${m.style}, BPM=${m.bpm}, 編成=${m.instruments.join(', ')})`,
          '- Sunoに貼れる依頼文（1〜5行、先頭に［STYLE:〜］［MOOD:〜］［BPM:〜］［INSTRUMENTS:〜］形式で音楽性を明記）',
          `- 画像の提案（例: シーン=${img.subject}, スタイル=${img.style})`,
          '- 画像生成向けの1行プロンプト',
          `- 魔法のひとこと（音楽性を喚起する短い比喩）: ${magic}`,
          '- 以後はこの結果を起点に日本語で会話しながら調整する',
          '',
          '【プレゼン作り方 — 完結版】に基づくプレゼン案も出力してください:',
          '- 目的（1文）: このプレゼンで相手にどう動いてほしいか',
          '- 3本柱: 1) 自分の強み（事例/数字で裏付け）, 2) 相手の課題との接点, 3) 未来への貢献（具体アクション）',
          '- スライド設計: 1スライド1メッセージ、短い言葉と図解',
          '- 流れ: 冒頭=目的提示 → 本文=3本柱 → 結論=目的の再強調',
          '- スライド構成案（8〜12枚）を番号付きで: 各スライドは「タイトル」「一文本文」「補足（任意）」の形式',
        ].join('\n');

        setOutput(chatSeed);
        el('outputs').classList.remove('hidden');
      }

      function generateAdvice(){
        const text = currentText();
        const full = text || '';
        const chatSeed = [
          '以下の文章に対して、執筆を前に進めるための具体的なアドバイスをください。',
          '',
          '【対象テキスト（全文）】',
          full || '(なし)',
          '',
          '【欲しい出力】',
          '- 視点の整理（何を主張したいか1〜2文）',
          '- 構成の提案（小見出し3つ程度）',
          '- 具体化ポイント（例や数字の入れ所）',
          '- 次に書くべき1〜3ステップ（チェックリスト）',
        ].join('\n');
        setOutput(chatSeed);
        el('outputs').classList.remove('hidden');
      }

      function generatePresentation(){
        const text = currentText();
        const full = (text || '');
        const chatSeed = [
          '【プレゼン支援】以下の材料から、短時間で形にできるプレゼン案を作ってください。',
          '',
          '【材料（全文）】',
          full || '(なし)',
          '',
          '【出力】',
          '- 目的（1文）',
          '- 3本柱（強み/接点/未来）',
          '- スライド構成案（8〜10枚、各: タイトル/一文/補足）',
          '- 最後に「相手にどう動いてほしいか」を再強調',
        ].join('\n');
        setOutput(chatSeed);
        el('outputs').classList.remove('hidden');
      }

      function generateMusicOnly(){
        const text = currentText();
        const s = summary(text);
        const m = inferMusic(text);
        const magic = buildMagicPhrase(text);
        const full = text || '';
        const seed = [
          'Suno への依頼（貼り付け用）:',
          `［STYLE:${m.style}］［MOOD:${m.mood}］［BPM:${m.bpm}］［INSTRUMENTS:${m.instruments.join('・') || '任意'}］`,
          `- スタイル: ${m.style}`,
          `- BPM: ${m.bpm}`,
          `- 編成: ${m.instruments.join(', ') || '(任意)'}`,
          `- 音楽性（雰囲気）: ${m.mood}`,
          `- 魔法のひとこと: ${magic}`,
          '- 構成: Intro(8) → Verse(16) → Chorus(16) → Bridge(8) → Chorus(16) → Outro(8)',
          `- キーワード: ${s}`,
          '',
          '【素材（全文）】',
          full || '(なし)',
          '雰囲気に合う短い日本語のボーカルフレーズを入れてください（任意）。',
        ].join('\n');
        setOutput(seed);
        el('outputs').classList.remove('hidden');
      }

      function generateRap(){
        const text = currentText();
        const full = (text || '');
        const s = summary(text);
        const m = inferMusic(text);
        const magic = buildMagicPhrase(full);
        const style = (m.style.includes('trap') || m.bpm >= 130) ? 'modern trap' : 'boom bap / lo-fi';
        const tempo = m.bpm >= 120 ? '速め' : (m.bpm >= 90 ? '中庸' : '遅め');
        const mood = m.mood || '柔らかな音楽性';
        const seed = [
          'ラップ作成依頼（貼り付け用）:',
          `- テーマ: ${s}`,
          `- ベースとなる音楽スタイル: ${style}（目安。素材に合うなら変更してOK）`,
          `- テンポ感: ${tempo}`,
          `- 音楽性・雰囲気: ${mood}`,
          `- 魔法のひとこと: ${magic}`,
          '',
          '【素材（全文）】',
          full || '(なし)',
          '',
          '【重要】テンプレ化せず、入力テキストの語彙・固有名詞・トーン・リズム感を最大限反映してください。比喩や言い回しも素材に寄せること。',
          '表記: 読みが不安定な語（例: AI）は「AI（エーアイ）」のように括弧内で読みを補い、歌詞中に自然に溶け込ませること。',
          '演出: 各セクション見出しは角括弧内にまとめ、［セクション名　音楽描写］（全角スペース1つで区切る）形式で書くこと。角括弧の外に同じ見出しを重ねず、例: ［Intro　静寂の中にゆらぐ残響］。',
          '構成: 素材に最適な構成をあなたが提案（例: Intro/Verse/Hook/Bridge…）。定型から外れてOK。各セクション名は明記。',
          '条件: 日本語。内部韻/脚韻は素材の語彙で多めに。フローは自然で、行間で抑揚が出るように。卑語は使わない。',
          '美しさ: 半角の数字や箇条書き記号を本文に使わない。必要なら漢数字や言葉で表す。視覚的に詩として美しく。',
          '出力: 見出し＋本文の歌詞のみ（説明や注釈は書かない）。最後は「テーマの要諦」を印象的に締める。',
        ].join('\n');
        setOutput(seed);
        el('outputs').classList.remove('hidden');
      }

      function generateImageOnly(){
        const text = currentText();
        const s = summary(text);
        const img = inferImage(text);
        const full = text || '';
        const seed = [
          '画像生成 依頼文（貼り付け用）:',
          `- シーン: ${img.subject}（文章の要約に基づく）`,
          `- スタイル: ${img.style}`,
          `- テキスト要約: ${s}`,
          '',
          '【参考テキスト（全文）】',
          full || '(なし)',
          '1行プロンプト:',
          `${img.subject}, ${img.style}, high detail, soft light, 16:9`,
        ].join('\n');
        setOutput(seed);
        el('outputs').classList.remove('hidden');
      }

      // Copy button
      document.querySelectorAll('[data-copy]').forEach(btn => btn.addEventListener('click', async (e)=>{
        const id = e.currentTarget.getAttribute('data-copy');
        const v = el(id).value || '';
        try { await navigator.clipboard.writeText(v); showToast('コピーしました'); } catch(err){
          el(id).select(); document.execCommand('copy'); showToast('コピーしました');
        }
      }));
      // Open raw preview in new tab
      el('openRaw').addEventListener('click', ()=>{
        const v = (el('chatOut').value || '');
        const w = window.open('', '_blank');
        if (!w) { showToast('ポップアップがブロックされました'); return; }
        const esc = (s)=> s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        w.document.write(`<!doctype html><meta charset="utf-8"><pre style="white-space:pre-wrap;word-wrap:break-word;">${esc(v)}</pre>`);
        w.document.close();
      });
      // Download as .txt
      el('saveTxt').addEventListener('click', ()=>{
        const v = (el('chatOut').value || '');
        const blob = new Blob([v], {type:'text/plain;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'chat-seed.txt';
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=> URL.revokeObjectURL(url), 500);
      });
      // Shortcut: ⌘/Ctrl + Enter で生成
      window.addEventListener('keydown', (ev)=>{
        if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === 'enter') { ev.preventDefault(); generate(); }
      });
      // アクションボタン
      el('advice').addEventListener('click', generateAdvice);
      el('pres').addEventListener('click', generatePresentation);
      el('music').addEventListener('click', generateMusicOnly);
      el('rap').addEventListener('click', generateRap);
      el('image').addEventListener('click', generateImageOnly);

      // タグ挿入（本文に簡単な依頼フレーズを付加）
      function insertAtCursor(text){
        const t = plainEl.value || '';
        const start = plainEl.selectionStart ?? t.length;
        const end = plainEl.selectionEnd ?? start;
        const before = t.slice(0, end);
        const after = t.slice(end);
        const ins = (before && !/\s$/.test(before) ? ' ' : '') + text + ' ';
        plainEl.value = before + ins + after;
        const caret = (before + ins).length;
        plainEl.setSelectionRange(caret, caret);
        plainEl.focus();
        updateCounts();
        showToast('タグを挿入しました');
      }
      el('tagMusic').addEventListener('click', ()=> insertAtCursor('[音楽依頼] この部分の雰囲気でSuno向けの曲案を提案して'));
      el('tagRap').addEventListener('click', ()=> insertAtCursor('[ラップ依頼] このテーマで16小節の日本語ラップを書いて'));
      el('tagImage').addEventListener('click', ()=> insertAtCursor('[画像依頼] この情景を画像生成向けに1行プロンプト化して'));
      // チャットの取り消しショートカットは廃止
      // UI chrome toggle: Esc または 右上ボタン
      function setZen(on){ document.body.classList.toggle('zen', !!on); }
      el('chromeToggle').addEventListener('click', ()=>{ document.body.classList.toggle('zen'); });
      // New session: 全ての入力/出力/タイマーをクリア
      function newSession(){
        plainEl.value = '';
        updateCounts();
        try { localStorage.removeItem(STORAGE_KEY); } catch(e) {}
        // hide outputs and clear
        el('chatOut').value = '';
        el('outputs').classList.add('hidden');
        // 旧キーは触らない（ユーザの他用途を尊重）
        // reset timer
        pause(); remaining = duration; hasStarted = false; renderTimer(); el('startPause').textContent='開始';
        showToast('新規セッションを開始しました');
      }
      el('newSession').addEventListener('click', newSession);
      window.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Escape') { document.body.classList.toggle('zen'); }
      });
      setZen(false);
      plainEl.focus();

      // Toast utility
      function showToast(text){
        const t = el('toast');
        if (!t) return;
        t.textContent = text;
        t.classList.add('show');
        clearTimeout(showToast._h);
        showToast._h = setTimeout(()=> t.classList.remove('show'), 1200);
      }
    </script>
  </body>
  </html>
