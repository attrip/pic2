<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Picture Diary — 25分集中チャット入力</title>
    <style>
      :root { --bg:#faf7f2; --fg:#222; --muted:#666; --accent:#4b9; --surface:#fff; --shadow:0 8px 32px rgba(0,0,0,.06); }
      html, body { height: 100%; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic UI", sans-serif; margin: 0; line-height: 1.7; color: var(--fg); background: radial-gradient(1200px 600px at 10% -10%, #fff, var(--bg)); }
      .wrap { max-width: 820px; margin: 32px auto 48px; padding: 0 16px; }
      h1 { margin: 0 0 6px; font-weight: 750; letter-spacing: .2px; }
      .note { color: var(--muted); font-size: 0.98em; margin: 0 0 14px; }
      .topbar { display: flex; align-items: baseline; gap: 16px; flex-wrap: wrap; }
      .timer { font-size: 28px; font-weight: 800; letter-spacing: .5px; }
      .progress { height: 6px; background: #e9e5df; border-radius: 999px; overflow: hidden; box-shadow: inset 0 1px 0 rgba(0,0,0,.03); }
      .bar { height: 100%; width: 100%; background: linear-gradient(90deg, #7dd, #4b9); transition: width .3s ease; }
      .controls { display:flex; gap: 8px; margin: 10px 0 16px; flex-wrap: wrap; }
      button { padding: 10px 14px; font-size: 14px; border: 0; border-radius: 8px; background: #eff7f5; color: #135; cursor: pointer; }
      button:hover { filter: brightness(0.98); }
      button:active { transform: translateY(1px); }
      .chat { margin-top: 12px; background: var(--surface); border: 1px solid #e8e2da; border-radius: 14px; box-shadow: var(--shadow); padding: 12px; max-height: 60vh; overflow: auto; }
      .bubble { background: #f5faf8; border: 1px solid #e0eee9; display: inline-block; padding: 10px 12px; border-radius: 12px; margin: 6px 0; max-width: 100%; white-space: pre-wrap; word-break: break-word; }
      .row { display: flex; gap: 8px; }
      .me { justify-content: flex-start; }
      .meta { color: #9aa; font-size: .8em; margin-top: 2px; }
      .composer { display: flex; gap: 8px; align-items: flex-end; margin-top: 10px; }
      .composer textarea { flex: 1; min-height: 46px; max-height: 200px; padding: 12px 12px; font-size: 16px; line-height: 1.6; border-radius: 10px; border: 1px solid #e8e2da; box-shadow: inset 0 1px 0 rgba(0,0,0,.03); resize: none; }
      .composer textarea:focus { outline: 2px solid #bfe9dd; outline-offset: 2px; }
      .statusline { display:flex; justify-content: space-between; color: var(--muted); font-size: .92em; margin: 8px 2px 0; }
      .hidden { display: none; }
      .out { margin-top: 22px; }
      .out h3 { margin: 18px 0 8px; }
      textarea.output { width: 100%; background: #0c0c0c; color: #e5ffe5; padding: 14px; border-radius: 10px; box-sizing: border-box; min-height: 120px; white-space: pre-wrap; }
      .small { color: var(--muted); font-size: .9em; }
      a { color: #06c; text-decoration: none; }
      a:hover { text-decoration: underline; }

      /* 集中モード（UIクロームを最小化） */
      body.zen .note,
      body.zen .controls,
      body.zen .statusline { display: none; }
      body.zen .wrap { margin-top: 24px; }
      body.zen .chat { background: transparent; border: none; box-shadow: none; padding: 0; }
      body.zen .composer textarea { background: #fff; }
      .chromeToggle { position: fixed; top: 10px; right: 10px; opacity: .5; background: #eef6f3; border-radius: 999px; padding: 6px 10px; border: 1px solid #dceae5; box-shadow: 0 2px 8px rgba(0,0,0,.05); cursor: pointer; }
      .chromeToggle:hover { opacity: .9; }
      body.zen .topbar .timer { position: fixed; top: 12px; left: 12px; font-size: 16px; opacity: .65; }
      body.zen .progress { position: fixed; top: 0; left: 0; right: 0; height: 2px; border-radius: 0; }

      /* トースト通知 */
      #toast { position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); background: rgba(20,20,20,.9); color: #fff; padding: 10px 14px; border-radius: 10px; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
      #toast.show { opacity: 1; }
    </style>
  </head>
  <body>
    <button id="chromeToggle" class="chromeToggle" title="UI表示切替">•••</button>
    <div class="wrap">
      <h1>Picture Diary</h1>
      <p class="note">文章だけに集中してください。音楽と画像の提案は自動で行います。書き始めると 25 分タイマーがスタートします（⌘/Ctrl + Enter で生成）。</p>

      <div class="topbar">
        <div class="timer" id="timer">25:00</div>
      </div>
      <div class="progress"><div class="bar" id="bar" style="width:100%"></div></div>
      <div class="controls">
        <button id="startPause">開始</button>
        <button id="reset">リセット</button>
        <button id="generate">今すぐ生成</button>
      </div>

      <div id="chat" class="chat" aria-live="polite"></div>
      <div class="composer">
        <textarea id="msgInput" placeholder="ここに書いて Enter で送信（改行は Shift+Enter）"></textarea>
        <button id="send">送信</button>
      </div>
      <div class="statusline">
        <div><span id="wc">0</span> words ・ <span id="cc">0</span> chars</div>
        <div id="save">&nbsp;</div>
      </div>

      <section id="outputs" class="out hidden">
      <h3>ChatGPT へ渡す依頼文（まとめ）</h3>
      <textarea id="chatOut" class="output" readonly></textarea>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button data-copy="chatOut">コピー</button>
        <a href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer"><button>ChatGPT を開く</button></a>
      </div>
      </section>
    </div>
    <div id="toast" role="status" aria-live="polite"></div>

    <script>
      const el = (id) => document.getElementById(id);
      const fmt = (s) => String(s).padStart(2, '0');
      const summary = (t) => { t=(t||'').trim(); return t.length>140 ? t.slice(0,140)+'…' : t; };

      // Pomodoro 25:00 timer
      let duration = 25 * 60;
      let remaining = duration;
      let timerId = null;
      let hasStarted = false;
      function renderTimer(){
        el('timer').textContent = `${fmt(Math.floor(remaining/60))}:${fmt(remaining%60)}`;
        const p = Math.max(0, Math.min(1, remaining / duration));
        const bar = document.getElementById('bar');
        if (bar) bar.style.width = `${Math.round(p*100)}%`;
      }
      function beep(){}
      function start(){
        if(timerId) return;
        timerId = setInterval(()=>{
          remaining--;
          if(remaining<=0){
            clearInterval(timerId); timerId=null; remaining=0; renderTimer(); beep(); generate();
          } else { renderTimer(); }
        }, 1000);
        hasStarted = true;
        el('startPause').textContent='一時停止';
      }
      function pause(){ if(!timerId) return; clearInterval(timerId); timerId=null; el('startPause').textContent='再開'; }
      function reset(){ pause(); remaining=duration; renderTimer(); hasStarted = false; el('startPause').textContent='開始'; }
      el('startPause').addEventListener('click', ()=>{ timerId ? pause() : start(); });
      el('reset').addEventListener('click', reset);
      el('generate').addEventListener('click', generate);
      renderTimer();
      // チャット入力: メッセージ配列 + 自動開始 + 入力オートリサイズ + カウント + 自動保存
      const chatEl = el('chat');
      const inputEl = el('msgInput');
      let messages = [];
      let undoStack = [];
      function renderChat(){
        chatEl.innerHTML = messages.map(m => `
          <div class="row me">
            <div>
              <div class="bubble">${escapeHtml(m.text)}</div>
              <div class="meta">${m.time}</div>
            </div>
          </div>
        `).join('');
        chatEl.scrollTop = chatEl.scrollHeight;
        updateCounts();
      }
      function now(){ const d=new Date(); return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`; }
      function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
      function autoresizeInput(){ inputEl.style.height='auto'; inputEl.style.height=Math.min(200, inputEl.scrollHeight)+'px'; }
      function addMessage(text){
        if(!text.trim()) return;
        const msg = { text: text.trim(), time: now() };
        messages.push(msg);
        undoStack.push({ type: 'send', message: msg });
        renderChat();
        persist();
      }
      function getAllText(){ return messages.map(m=>m.text).join('\n'); }
      function updateCounts(){ const t = getAllText(); const words=(t.trim().match(/\S+/g)||[]).length; el('wc').textContent=String(words); el('cc').textContent=String(t.length); }
      function persist(){ try { localStorage.setItem('pd_msgs', JSON.stringify(messages)); el('save').textContent='保存済み'; } catch(e){} }
      // restore
      try { const raw = localStorage.getItem('pd_msgs'); if(raw){ messages = JSON.parse(raw)||[]; renderChat(); } } catch(e) {}
      // start on first input typing
      inputEl.addEventListener('input', ()=>{ if(!hasStarted && !timerId && remaining===duration){ start(); } autoresizeInput(); el('save').textContent='入力中…'; });
      inputEl.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Enter' && !ev.shiftKey){ ev.preventDefault(); sendCurrent(); }
      });
      el('send').addEventListener('click', sendCurrent);
      function sendCurrent(){ const t = inputEl.value; inputEl.value=''; autoresizeInput(); addMessage(t); }

      // Infer music/image from text
      function inferMusic(text){
        const t = text || '';
        const has = (kw) => kw.some(k => t.includes(k));
        if (has(['夜','ネオン','都会','雨','ビル'])) return {style:'synthwave / citypop', bpm:112, instruments:['synth bass','retro drums','pads','electric piano']};
        if (has(['自然','森','海','山','風','空','川','光'])) return {style:'ambient / organic', bpm:96, instruments:['acoustic guitar','piano','soft percussion','field recordings']};
        if (has(['楽しい','嬉','ワクワク','陽気','笑'])) return {style:'upbeat pop / electronic', bpm:128, instruments:['drums','bass','synth lead','claps']};
        if (has(['悲しい','寂','疲れ','静か','落ち着','雨'])) return {style:'lo-fi chill', bpm:80, instruments:['warm keys','vinyl noise','soft drums','sub bass']};
        if (has(['疾走','焦り','緊張','駆け抜け'])) return {style:'drum & bass', bpm:172, instruments:['breakbeat drums','reese bass','pads']};
        return {style:'lo-fi chillhop', bpm:82, instruments:['warm keys','soft drums','bass']};
      }

      function inferImage(text){
        const t = text || '';
        if (['夜','ネオン','都会'].some(k=>t.includes(k))) return {style:'cinematic night, neon lights, high contrast', subject:'夜の街並み'};
        if (['自然','森','海','山','空','風','光'].some(k=>t.includes(k))) return {style:'pastel watercolor, soft light, atmospheric', subject:'自然の情景'};
        if (['楽しい','嬉','ワクワク','陽気'].some(k=>t.includes(k))) return {style:'colorful illustration, playful, clean', subject:'明るい日常の一場面'};
        if (['悲しい','寂','静か','落ち着'].some(k=>t.includes(k))) return {style:'moody film still, shallow depth of field', subject:'静かな部屋の一角'};
        return {style:'minimal, soft light, clean composition', subject:'印象的な日常の瞬間'};
      }

      function generate(){
        const text = getAllText();
        const s = summary(text);
        const m = inferMusic(text);
        const img = inferImage(text);

        const chatSeed = [
          'あなたは私の相棒です。以下の文章を材料に、短い要約と内省（各1〜3文）を返し、その内容に最も合う音楽（Sunoで実現可能）と画像の方向性を日本語で具体提案してください。',
          '',
          `【入力】\n${s || '(なし)'}`,
          '',
          '【出力要件】',
          '- 要約（1〜3文）',
          '- 内省（1〜3文）',
          `- 音楽の提案（例: スタイル=${m.style}, BPM=${m.bpm}, 編成=${m.instruments.join(', ')})`,
          '- Sunoに貼れる依頼文（1〜5行）',
          `- 画像の提案（例: シーン=${img.subject}, スタイル=${img.style})`,
          '- 画像生成向けの1行プロンプト',
          '- 以後はこの結果を起点に日本語で会話しながら調整する',
          '',
          '【プレゼン作り方 — 完結版】に基づくプレゼン案も出力してください:',
          '- 目的（1文）: このプレゼンで相手にどう動いてほしいか',
          '- 3本柱: 1) 自分の強み（事例/数字で裏付け）, 2) 相手の課題との接点, 3) 未来への貢献（具体アクション）',
          '- スライド設計: 1スライド1メッセージ、短い言葉と図解',
          '- 流れ: 冒頭=目的提示 → 本文=3本柱 → 結論=目的の再強調',
          '- スライド構成案（8〜12枚）を番号付きで: 各スライドは「タイトル」「一文本文」「補足（任意）」の形式',
        ].join('\n');

        el('chatOut').value = chatSeed;
        el('outputs').classList.remove('hidden');
      }

      // Copy button
      document.querySelectorAll('[data-copy]').forEach(btn => btn.addEventListener('click', async (e)=>{
        const id = e.currentTarget.getAttribute('data-copy');
        const v = el(id).value || '';
        try { await navigator.clipboard.writeText(v); showToast('コピーしました'); } catch(err){
          el(id).select(); document.execCommand('copy'); showToast('コピーしました');
        }
      }));
      // Shortcut: ⌘/Ctrl + Enter で生成
      window.addEventListener('keydown', (ev)=>{
        if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === 'enter') { ev.preventDefault(); generate(); }
      });
      // Shortcut: ⌘/Ctrl + Z で直前の送信を取り消し（入力欄が空のとき）
      function undoLastSend(){
        if (messages.length === 0) return;
        const last = messages.pop();
        inputEl.value = last.text;
        autoresizeInput();
        renderChat();
        persist();
        el('save').textContent = '取り消しました';
        setTimeout(()=>{ el('save').textContent = '保存済み'; }, 1200);
      }
      window.addEventListener('keydown', (ev)=>{
        if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === 'z' && !ev.shiftKey) {
          if (document.activeElement === inputEl && (inputEl.value || '').length === 0) {
            ev.preventDefault();
            undoLastSend();
          }
        }
      });
      // UI chrome toggle: Esc または 右上ボタン
      function setZen(on){ document.body.classList.toggle('zen', !!on); }
      el('chromeToggle').addEventListener('click', ()=>{ document.body.classList.toggle('zen'); });
      window.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Escape') { document.body.classList.toggle('zen'); }
      });
      setZen(true);
      inputEl.focus();

      // Toast utility
      function showToast(text){
        const t = el('toast');
        if (!t) return;
        t.textContent = text;
        t.classList.add('show');
        clearTimeout(showToast._h);
        showToast._h = setTimeout(()=> t.classList.remove('show'), 1200);
      }
    </script>
  </body>
  </html>
